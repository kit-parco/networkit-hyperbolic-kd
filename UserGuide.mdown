# NetworKit User Guide

This text is meant as an introduction to using NetworKit for network analysis. We assume that you have read the Readme and successfully built the core library and the Python module.


## Startup

Start a Python 3 shell. The standard shell works fine, although [IPython](http://ipython.org/) is what you really want for data interactive programming and data analysis. These example sessions were created with IPython.

NetworKit can be imported like a standard Python module:

	In[] import NetworKit

or

	In[] from NetworKit import *

In the following, we will assume the latter way for brevity.

## Reading Graphs from Disk

There is a large variety of formats for storing graph data in files. For NetworKit, the currently best supported format is the [METIS adjacency format](http://people.sc.fsu.edu/~jburkardt/data/metis_graph/metis_graph.html). Various example graphs in this format can be found [here](http://www.cc.gatech.edu/dimacs10/downloads.shtml). Assume we download the file [PGPgiantcompo.graph](http://www.cc.gatech.edu/dimacs10/archive/data/clustering/PGPgiantcompo.graph.bz2). There is a reader class named `METISGraphReader` in the `graphio` submodule:

	In[] G = graphio.METISGraphReader().read("PGPgiantcompo.graph")
		[BEGIN] reading graph G(n=10680, m=24316) from METIS file: 10% 20.0094%
		 30.0187% 40.0281% 50.0375% 60.0468% 70.0562% 80.0655% 90.0749% [DONE]

More reader classes can be found in the `graphio` module. However, there is also a convenient input function which tries to guess the input format and select the appropriate reader:

	In[] G = readGraph("PGPgiantcompo.graph")
		[BEGIN] reading graph G(n=10680, m=24316) from METIS file: 10% 20.0094%
		 30.0187% 40.0281% 50.0375% 60.0468% 70.0562% 80.0655% 90.0749% [DONE]

## The Graph Object

The variable `G` now contains the network represented as an undirected graph.

	In [10]: G
	Out[10]: <_NetworKit.Graph at 0x7f71c9e519c0>


For NetworKit, nodes are just integer indexes and edges are tuples of nodes. `G` already provides a number of methods:

	In [11]: G.
	G.addEdge             G.edges               G.hasEdge
	G.markAsWeighted      G.numberOfEdges       G.removeEdge          G.toString            
	G.addNode             G.getName             G.isMarkedAsWeighted
	G.nodes               G.numberOfNodes       G.removeNode          G.weight 

For example, we could check if nodes 42 and 43 are connected:

	In [20]: G.hasEdge(42,43)
	Out[20]: False


## Using Algorithms

### Connected Components

Our first example of a network analysis algorithm is `ConnectedComponents. In order to determine the connected components of the network, enter the following:

	In [22]: cc = properties.ConnectedComponents()

	In [23]: cc.run(G)

The `cc` object has now performed the calculation and results can be requested through different method calls.

	In [24]: cc.numberOfComponents()
	Out[24]: 1

	In [25]: cc.sizeOfComponent(0)
	Out[25]: 10680

Not surprisingly, `PGPgiantcompo` has a single connected component containing all nodes.


### Community Detection

NetworKit contains several algorithms for parallel community detection, contained in the `community` submodule. The `PLM` class implements a parallel heuristic known as the Louvain method. Let's apply it to `G

	In [26]: zeta = community.PLM().run(G)

Computation will not take long for a relatively small network like `PGPgiantcompo`. The resulting partition is stored in the variable `zeta`, which internally stores a mapping from node index to community index. It also provides useful methods:

	In [27]: zeta.numberOfClusters()
	Out[27]: 90

We see that 90 communities have been found. Let's examine their sizes:

	In [30]: zeta.clusterSizes()
	Out[30]: [215, 355, 171, 563, 385, 235, 275, 137, 17, 691,
	 	360, 20, 482, 295, 99, 353, 121, 140, 262, 185, 212, 40, 368,
		82, 85, 78, 356, 16, 364, 772, 271, 31, 64, 77, 313, 333,
	   	28, 129, 67, 17, 15, 51, 12, 23, 27, 21, 57, 7, 37, 24, 69,
	    7, 26, 297, 28, 50, 45, 83, 24, 41, 47, 16, 28, 14, 25, 14,
	    8, 11, 68, 33, 26, 37, 6, 16, 19, 17, 76, 29, 27, 13, 8,
	    12, 14, 7, 18, 24, 14, 25, 9, 11]

It becomes clear that the communities are quite unevenly sized. We can also ask for the community of a specific node:
x
	In [14]: zeta.clusterOf(42)
	Out[14]: 10

	In [15]: zeta.getMembers(10)
			# output omitted for brevity


## Overview Network Properties

Let us now inspect more basic properties of the graph. The functions for this are mostly located in the `properties` module (though module structure is subject to change). For example, this function gives us a tuple containing the number of nodes and the number of edges:

	In [7]: properties.nm(G)
	Out[7]: (10680, 24316)


## Compatibility with NetworkX

[NetworkX](http://networkx.github.io/) is a Python package with a large collection of network analysis methods and graph algorithms. NetworKit provides functions to convert graph objects and thereby connects the two modules.


	In [6]: import networkx

The function `nk2nx` converts a `NetworKit.Graph` to a `networkx.Graph`:

	In [4]: nxG = nk2nx(G)

	In [5]: nxG
	Out[5]: <networkx.classes.graph.Graph at 0x7fb1a453f390>


Now we can also use some of the many NetworkX functions, e.g.

	In [13]: networkx.degree_assortativity_coefficient(nxG)
	Out[13]: 0.23821137170818882

Note however that NetworkX data structures are more memory-intensive and its algorithms do not target very large graphs. You are likely to reach limits of your machine for graphs with millions of edges, while NetworKit aims for good performance three magnitudes larger.


## Settings

### Verbosity

The C++ kernel of NetworKit outputs text to the terminal via the [log4cxx](http://logging.apache.org/log4cxx/) library. The amount of detail is controlled by the current log level, which is one of `TRACE`, `DEBUG`, `INFO`, `WARN`, and `ERROR`. By default, the log level is `ERROR`. You can set the log level at runtime and do this from the Python shell:

	>>> NetworKit.configureLogging(loglevel="DEBUG")
	>>> NetworKit.currentLogLevel()
		'ERROR'


/*
 * LinkPredictor.h
 *
 *  Created on: 28.02.2015
 *      Author: Kolja Esders (kolja.esders@student.kit.edu)
 */

#ifndef LINKPREDICTOR_H_
#define LINKPREDICTOR_H_

#include <memory>

#include "../graph/Graph.h"

namespace NetworKit {

/**
 * @ingroup linkprediction
 *
 * Abstract base class for link predictors.
 */
class LinkPredictor {
public:
  // Declare typedef in advance for use in the protected section
  typedef std::pair<std::pair<node, node>, double> node_dyad_score_pair; //!< Type of predictions

private:
  /**
   * Subclasses implement this private method to inject the custom predictor-code.
   * Subclasses don't have to check whether the arguments are valid or a graph is set.
   * @param u First node in graph
   * @param v Second node in graph
   * @return a prediction-score indicating the likelihood of a future link between the given nodes
   */
  virtual double runImpl(node u, node v) = 0;

protected:
  /**
   * Comparator used to sort predictions descendingly by score and on equality
   * ascendingly by node-pairs which means e.g. (0, 1) < (1, 1) and (0, 0) < (0, 1).
   */
  struct ScoreComp {
    bool operator()(const node_dyad_score_pair& a, const node_dyad_score_pair& b) const {
      return (a.second > b.second) || (a.second == b.second && a.first < b.first);
    }
  } static ConcreteScoreComp; //!< Comparator instance for score-based comparison

  /**
   * Comparator used to sort predictions ascendingly by node-pairs.
   */
  struct NodePairComp {
    bool operator()(const node_dyad_score_pair& a, const node_dyad_score_pair& b) const {
      return a.first < b.first;
    }
  } static ConcreteNodePairComp; //!< Comparator instance for node-pair-based comparison

  const Graph* G; //!< Graph to operate on

  bool validCache; //!< Indicates whether a possibly used cache is valid

public:
  LinkPredictor();

  /**
   *
   * @param G The graph to work on
   */
  explicit LinkPredictor(const Graph& G);

  /**
   * Default destructor.
   */
  virtual ~LinkPredictor() = default;

  /**
   * Sets the graph to work on.
   * @param newGraph The graph to work on
   */
  virtual void setGraph(const Graph& newGraph);

  /**
   * Returns a score indicating the likelihood of a future link between the given nodes.
   * Prior to calling this method a graph should be provided through the constructor or
   * by calling setGraph. Note that only undirected graphs are accepted.
   * There is also no lower or upper bound for scores and the actual range of values depends
   * on the specific link predictor implementation. In case @a u == @a v a 0 is returned.
   * If suitable this method might make use of parallelization to enhance performance.
   * @param u First node in graph
   * @param v Second node in graph
   * @return a prediction-score indicating the likelihood of a future link between the given nodes
   */
  virtual double run(node u, node v);

  /**
   * Executes the run-method on aÄºl given @a nodePairs and returns a vector of predictions.
   * The result is a vector of pairs where the first element is the node-pair and it's second
   * element the corresponding score generated by the run-method.
   * @param nodePairs Node-pairs to run the predictor on
   * @return a vector of pairs containing the given node-pair as the first element and it's
   * corresponding score as the second element. The vector is sorted ascendingly by node-pair
   */
  virtual std::vector<node_dyad_score_pair> runOn(std::vector<std::pair<node, node>> nodePairs);

  /**
   * Parallel implementation of runOn(). See runOn() for details.
   * @param nodePairs Node-pairs to run the predictor on
   * @return a vector of pairs containing the given node-pair as the first element and it's
   * corresponding score as the second element. The vector is sorted ascendingly by node-pair
   */
  virtual std::vector<node_dyad_score_pair> runOnParallel(std::vector<std::pair<node, node>> nodePairs);

  /**
   * Runs the link predictor on all currently unconnected node-pairs.
   * Possible self-loops are also excluded.
   * @return a vector of pairs containing all currently unconnected node-pairs as the first elements
   * and the corresponding scores as the second elements. The vector is sorted ascendingly by node-pair
   */
  virtual std::vector<node_dyad_score_pair> runAll();

  /**
   * Sorts the @a predictions descendingly by score.
   * In case there is a tie the node-pairs are used as a tie-breaker by sorting them
   * ascendingly on the first node and on a tie ascendingly by the second node.
   * @param predictions The predictions to sort
   */
  static void sortByScore(std::vector<node_dyad_score_pair>& predictions);

  /**
   * Sorts the @a predictions ascendingly by node-pair.
   * This means for example (0, 0) < (0, 1) and (1, 1) < (1, 0).
   * @param predictions The predictions to sort
   */
  static void sortByNodePair(std::vector<node_dyad_score_pair>& predictions);
  
};

} // namespace NetworKit

#endif /* LINKPREDICTOR_H_ */